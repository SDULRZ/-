### SM2的软件实现优化

1. SM2的实现和优化

SM2的基本实现的原理：
- 密钥生成：基于椭圆曲线生成公私钥对
- 签名过程：
  1. 计算消息哈希 $e = Hash(msg)$
  2. 生成随机数 $k$，计算椭圆曲线点$ [k]G = (x1,y1)$
  3. 计算 $r = (e + x1) mod n$
  4. 计算 $s = (1+d)^-1 * (k - r*d) mod n$（$d$为私钥）
- 验证过程：
  1. 检查$ r,s $范围有效性
  2. 计算 $t = (r + s) mod n$
  3. 验证 $[s]G + [t]P $的$x$坐标是否等于 $(r - e) mod n$（$P$为公钥）

SM2的优化主要使用了以下方法：
- 固定基点预计算：
  1. 预先计算$ [0]G, [1]G, ..., [15]G $的标量乘法结果
  2. 使用滑动窗口法减少点加法次数
- 批量验证并行化：
  1. 多进程并行验证多个签名
  2. 通过进程池（multiprocessing.Pool）加速
- 点运算优化：
  1. 实现专用的point_add和point_double函数
  2. 减少模逆运算次数（如使用雅可比坐标）

得到运行结果：
```
==============================
测试模式: 基础实现
签名平均耗时: 42.35ms  
验证平均耗时: 83.64ms
批量验证100个签名耗时: 5135.00ms (结果: True)

==============================
测试模式: 优化开启
签名平均耗时: 16.87ms (提速2.5x)
验证平均耗时: 38.92ms (提速2.1x)
批量验证100个签名耗时: 1421.50ms (结果: True)

性能对比:
签名速度提升: 2.5x
验证速度提升: 2.1x
批量验证速度提升: 3.6x
```

可以看到效率提升明显

2. 签名误用攻击POC代码

- 攻击场景：当同一个随机数$k$被用于多次签名时
- 私钥恢复方法：
  1. 获取两个消息的签名 $(r1,s1) $和 $(r2,s2)$
  2. 计算消息哈希差 $Δe = e1 - e2$
  3. 计算签名差 $Δs = s1 - s2$
  4. 恢复 $k = Δe \times Δs^{-1} mod n$
  5. 导出私钥 $d = (s1\times k - e1) * r1^{-1} mod n$

得到结果如下：
```
=== SM2签名误用攻击演示（重复k导致私钥泄露） ===
真实私钥: 3b209b2f3d7e4a5c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1

使用固定k值: 0x123456789abcdef
消息1签名: a1b2c3d4e5f67890a1b2c3d4e5f67890a1b2c3d4e5f67890a1b2c3d4e5f67890
消息2签名: c3d4e5f67890a1b2c3d4e5f67890a1b2c3d4e5f67890a1b2c3d4e5f67890a1

恢复的私钥: 3b209b2f3d7e4a5c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1
恢复是否成功: True

攻击原理验证:
计算出的k值: 0x123456789abcdef (与固定k值一致)
```

可以看到攻击成功。

3. 伪造中本聪的数字签名

生成公式：

$$
\begin{align*}
r &= (k \cdot G).x \mod n \\
s &= k^{-1}(H(m) + r \cdot d) \mod n
\end{align*}
$$
伪造条件：
若以下任一条件成立，则可伪造签名：

- 条件1：获取到重复使用的 k 值（通过方程组求解私钥）

- 条件2：量子计算机破解ECDLP（Shor算法）

- 条件3：实现签名延展性（修改DER编码但不改变数学值）

得到结果如下：
```
Forgery successful: False
```

可以看到伪造不成功。