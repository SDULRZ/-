### Google Password Checkup验证

通过密码学技术让两个参与方（P1和P2）在不暴露各自原始数据的情况下，计算双方数据集的交集大小以及交集内关联数值的总和。

核心技术：

  1. 双盲化
  - 目的：隐藏原始ID，防止双方直接看到对方的明文数据。
  - 步骤：
      1. P1和P2各自生成私密随机数 $k1$ 和 $k2$。
      2. 双方通过哈希函数将ID映射到数学群：
          P1计算：$H(v_i)^{k1}$（发送给P2）
          P2计算：$H(w_j)^{k2}$（发送给P1）
      3. 双方交换后，进一步计算双重加密的ID：
          P1得到：$H(w_j)^{k1k2}$
          P2得到：$H(v_i)^{k1k2}$
  - 效果：只有双方共有的ID才能匹配，但无法反推原始ID。
  
  2. 同态加密
  - 目的：在不暴露P2的关联值的情况下求和。
  - 实现：
      1. P2用同态加密算法加密每个关联值。
      2. P1在加密状态下添加随机掩码$Enc(100 + random_mask)$。
      3. P2解密后得到掩码后的和，P1最终减去掩码部分得到真实和。

  - 关键性质：加密状态下的加法$ Enc(a) + Enc(b) = Enc(a+b)$。
  
协议流程：

  1. P1发送盲化ID：P1计算所有ID的哈希值并盲化$H(v_i)^{k1}$，发送给P2。

  2. P2加密并返回：P2盲化自己的ID（$H(w_j)^{k2}$），同时加密关联值，打乱顺序后返回给P1（防止通过顺序推断匹配关系）。

  3. P1二次盲化：P1对P2的盲化ID再次盲化$H(w_j)^{k1k2}$，并添加随机掩码到加密值。

  4. P2计算交集和：P2通过对比双重盲化ID找到交集，对加密值求和后返回给P1。

  5. P1解密最终结果：P1减去掩码，得到真实的关联值总和。

隐私保护原理：
  - P1看不到P2的数据：P2的ID通过$ H(w_j)^{k2} $隐藏，关联值通过同态加密隐藏。

  - P2看不到P1的原始ID：P1的ID通过$ H(v_i)^{k1} $和双重盲化隐藏。

  - 抗推断：打乱顺序、随机掩码防止通过时间或顺序推断匹配关系。
  
得到结果如下：
```
交集大小: 3
关联值总和: 450
实际交集: {'user1', 'user2', 'user3'}
```

可以看到代码成功实现了计算和验证。